use crate::ast::*;

grammar;

pub Program: Program = {
    (<Stmt>)* => Program { statements: <> },
};

Stmt: Statement = {
    <start: @L> "var" <name:Ident> <type_:(":" <TypeExpr>)?> <initializer:("=" <Expr>)?> ";" <end: @R> => {
        Statement::VarDecl(VarDeclStmt {
            variable_name: name,
            variable_type: type_,
            initializer,
            span: InputSpan { start, end },
        })
    },

    <start: @L> "read" <variable_name:Ident> ";" <end: @R> => {
        Statement::Read(ReadStmt {
            variable_name,
            span: InputSpan { start, end },
        })
    },

    <start: @L> "write" <expression:Expr> ";" <end: @R> => {
        Statement::Write(WriteStmt {
            expression,
            span: InputSpan { start, end },
        })
    },

    // If-statements are different from if-expressions: they are allowed to not have an `else` branch.
    // Splitting the two syntactically also helps to solve the dangling else issue.
    <start: @L> "if" "(" <cond:Expr> ")" <then:BlockStmt> <else_:("else" <BlockStmt>)?> <end: @R> => {
        Statement::If(IfStmt {
            cond: Box::new(cond),
            then: Box::new(then),
            else_: else_.map(Box::new),

            span: InputSpan { start, end },
        })
    },

    <start: @L> <expression:Expr> ";" <end: @R> => {
        Statement::Expr(ExprStmt {
            expression,
            span: InputSpan { start, end },
        })
    },

    BlockStmt
};

BlockStmt: Statement = {
    <start: @L> "{" <statements:(<Stmt>)*> "}" <end: @R> => {
        Statement::Block(BlockStmt {
            statements,
            span: InputSpan { start, end },
        })
    },
};

// Expressions are ordered from lowest to highest precedence.
Expr: Expression = {
    <Expr5> => <>,
};

// Highest tier handles if-expressions.
Expr5: Expression = {
    <start: @L> "if" "(" <cond:Expr> ")" <then:Expr> "else" <else_:Expr> <end: @R> => {
        Expression::If(IfExpr {
            cond: Box::new(cond),
            then: Box::new(then),
            else_: Box::new(else_),
            span: InputSpan { start, end },
        })
    },
    Expr4,
}

// Macro for a left-associative binary operator expression tier.
LeftAssocBinaryOpExprTier<Ops, PrevTier>: Expression = {
    <start: @L> <lhs:LeftAssocBinaryOpExprTier<Ops, PrevTier>> <operator:Ops> <rhs:PrevTier> <end: @R> => {
        Expression::BinaryOp(BinaryOperatorExpr {
            operator,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            span: InputSpan { start, end },
        })
    },
    PrevTier,
}

Expr4 = LeftAssocBinaryOpExprTier<Expr4Op, Expr3>;
Expr4Op: BinaryOperator = {
    "==" => BinaryOperator::Eq,
    "!=" => BinaryOperator::NotEq,
}

Expr3 = LeftAssocBinaryOpExprTier<Expr3Op, Expr2>;
Expr3Op: BinaryOperator = {
    "<" => BinaryOperator::Less,
    ">" => BinaryOperator::Greater,
    "<=" => BinaryOperator::LessEq,
    ">=" => BinaryOperator::GreaterEq,
}

Expr2 = LeftAssocBinaryOpExprTier<Expr2Op, Expr1>;
Expr2Op: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Sub,
}

Expr1 = LeftAssocBinaryOpExprTier<Expr1Op, Expr0>;
Expr1Op: BinaryOperator = {
    "*" => BinaryOperator::Mul,
}

Expr0: Expression = {
    <start: @L> <name:Ident> <end: @R> => {
        Expression::Variable(VariableExpr {
            name,
            span: InputSpan { start, end },
        })
    },

    <start: @L> <value:IntLiteral> <end: @R> => {
        Expression::IntLiteral(IntLiteralExpr {
            value,
            span: InputSpan { start, end },
        })
    },

    <start: @L> "(" <e:Expr> ")" <end: @R> => {
        e.map_span(|_| InputSpan { start, end })
    },

    <start: @L> "{" <statements:(<Stmt>)*> <final_expr:Expr> "}" <end: @R> => {
        Expression::Block(BlockExpr {
            statements,
            final_expr: Box::new(final_expr),
            span: InputSpan { start, end },
        })
    }
}

TypeExpr: TypeExpr = {
    <start: @L> <name:Ident> <end: @R> => TypeExpr { name, span: InputSpan { start, end } }
}

Ident: String = {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => String::from(<>)
};

IntLiteral: i32 = {
    r"-?[0-9]+" => <>.parse().unwrap(),
};
