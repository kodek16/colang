use crate::ast::*;

grammar;

pub Program: Program = {
    (<FunctionDef>)* => Program { functions: <> },
};

FunctionDef: FunctionDef = {
    <start: @L> KwFun <name:Ident> "(" ")" <return_type:(":" <TypeExpr>)?> <end: @R> <body:Block> => {
        FunctionDef {
            name,
            return_type,
            body,
            signature_span: InputSpan { start, end }
        }
    }
};

Stmt: Statement = {
    StmtNotExpr,

    <start: @L> <expression:ExprWithoutBlock> ";" <end: @R> => {
        Statement::Expr(ExprStmt {
            expression,
            span: InputSpan { start, end },
        })
    },

    <start: @L> <expression:ExprWithBlock> <end: @R> => {
        Statement::Expr(ExprStmt {
            expression,
            span: InputSpan { start, end },
        })
    },
}

StmtNotExpr: Statement = {
    <start: @L> KwVar <entries:CommaSeparatedNotEmpty<VarDeclEntry>> ";" <end: @R> => {
        Statement::VarDecl(VarDeclStmt {
            entries,
            span: InputSpan { start, end },
        })
    },

    <start: @L> KwRead <entries:CommaSeparatedNotEmpty<ReadEntry>> ";" <end: @R> => {
        Statement::Read(ReadStmt {
            entries,
            span: InputSpan { start, end },
        })
    },

    <start: @L> KwWrite <expression:Expr> ";" <end: @R> => {
        Statement::Write(WriteStmt {
            expression,
            span: InputSpan { start, end },
        })
    },

    <start: @L> KwWhile <cond:Expr> <body:Block> <end: @R> => {
        Statement::While(WhileStmt {
            cond: Box::new(cond),
            body: Box::new(body),
            span: InputSpan { start, end },
        })
    },

    <start: @L> <lhs:Expr> "=" <rhs:Expr> ";" <end: @R> => {
        Statement::Assign(AssignStmt {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            span: InputSpan { start, end },
        })
    },
};

VarDeclEntry: VarDeclEntry = {
    <start: @L> <name: Ident> <type_:(":" <TypeExpr>)?> <initializer:("=" <Expr>)?> <end: @R> => {
        VarDeclEntry {
            variable_name: name,
            variable_type: type_,
            initializer,
            span: InputSpan { start, end },
        }
    }
};

ReadEntry: ReadEntry = {
    <start: @L> <name: Ident> <end: @R> => {
        ReadEntry {
            variable_name: name,
            span: InputSpan { start, end },
        }
    }
}

// Expressions are defined from lowest to highest precedence (Expr0 is highest).
// The top-level non-terminal structure handles the dangling-else problem.
// (https://en.wikipedia.org/wiki/Dangling_else)
Expr: Expression = {
    OpenExpr,
    ClosedExpr,
};

ExprWithBlock: Expression = {
    OpenExpr,
    ClosedIfExpr,
};

OpenExpr: Expression = {
    <start: @L> KwIf "(" <cond:Expr> ")" <then:Expr> <end: @R> => {
        Expression::If(If {
            cond: Box::new(cond),
            then: Box::new(then),
            else_: None,
            span: InputSpan { start, end },
        })
    },
    <start: @L> KwIf "(" <cond:Expr> ")" <then:ClosedExpr> KwElse <else_:OpenExpr> <end: @R> => {
        Expression::If(If {
            cond: Box::new(cond),
            then: Box::new(then),
            else_: Some(Box::new(else_)),
            span: InputSpan { start, end },
        })
    },
};

ClosedExpr: Expression = {
    NonIfExpr,
    ClosedIfExpr,
}

ClosedIfExpr: Expression = {
    <start: @L> KwIf "(" <cond:Expr> ")" <then:ClosedExpr> KwElse <else_:ClosedExpr> <end: @R> => {
        Expression::If(If {
            cond: Box::new(cond),
            then: Box::new(then),
            else_: Some(Box::new(else_)),
            span: InputSpan { start, end },
        })
    },
};

NonIfExpr: Expression = {
    ExprWithoutBlock,
    Block => Expression::Block(<>),
};

// Lowest precedence level.
ExprWithoutBlock = Expr4;

Expr4 = LeftAssocBinaryOpExprTier<Expr4Op, Expr3>;
Expr4Op: BinaryOperator = {
    "==" => BinaryOperator::Eq,
    "!=" => BinaryOperator::NotEq,
}

Expr3 = LeftAssocBinaryOpExprTier<Expr3Op, Expr2>;
Expr3Op: BinaryOperator = {
    "<" => BinaryOperator::Less,
    ">" => BinaryOperator::Greater,
    "<=" => BinaryOperator::LessEq,
    ">=" => BinaryOperator::GreaterEq,
}

Expr2 = LeftAssocBinaryOpExprTier<Expr2Op, Expr1>;
Expr2Op: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Sub,
}

Expr1 = LeftAssocBinaryOpExprTier<Expr1Op, Expr0>;
Expr1Op: BinaryOperator = {
    "*" => BinaryOperator::Mul,
}

Expr0: Expression = {
    <start: @L> <name:Ident> <end: @R> => {
        Expression::Variable(VariableExpr {
            name,
            span: InputSpan { start, end },
        })
    },

    <start: @L> <value:IntLiteral> <end: @R> => {
        Expression::IntLiteral(IntLiteralExpr {
            value,
            span: InputSpan { start, end },
        })
    },

    <start: @L> "(" <e:Expr> ")" <end: @R> => {
        e.map_span(|_| InputSpan { start, end })
    },
}

Block: BlockExpr = {
    <start: @L> "{" "}" <end: @R> => {
        BlockExpr {
            statements: vec![],
            final_expr: None,
            span: InputSpan { start, end },
        }
    },

    <start: @L> "{" <statements:(<Stmt>)*> <final_stmt:StmtNotExpr> "}" <end: @R> => {
        let mut statements = statements;
        statements.push(final_stmt);
        BlockExpr {
            statements,
            final_expr: None,
            span: InputSpan { start, end },
        }
    },

    <start: @L> "{" <statements:(<Stmt>)*> <final_expr:Expr> "}" <end: @R> => {
        BlockExpr {
            statements,
            final_expr: Some(Box::new(final_expr)),
            span: InputSpan { start, end },
        }
    },
};

TypeExpr: TypeExpr = {
    <start: @L> <name:Ident> <end: @R> => TypeExpr { name, span: InputSpan { start, end } }
}

Ident: String = {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => String::from(<>)
};

IntLiteral: i32 = {
    r"-?[0-9]+" => <>.parse().unwrap(),
};

// Keywords:
KwVar: () = { "var" }
KwRead: () = { "read" }
KwWrite: () = { "write" }
KwIf: () = { "if" }
KwElse: () = { "else" }
KwWhile: () = { "while" }
KwFun: () = { "fun" }

// Macros:
CommaSeparatedNotEmpty<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

LeftAssocBinaryOpExprTier<Ops, PrevTier>: Expression = {
    <start: @L> <lhs:LeftAssocBinaryOpExprTier<Ops, PrevTier>> <operator:Ops> <rhs:PrevTier> <end: @R> => {
        Expression::BinaryOp(BinaryOperatorExpr {
            operator,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            span: InputSpan { start, end },
        })
    },
    PrevTier,
}
